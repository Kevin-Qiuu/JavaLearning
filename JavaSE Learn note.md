# JavaSE

## JDK、JRE与JVM之间的关系

## 方法重载

1、方法名称一定相同

2、参数列表要不同（参数的个数、类型以及类型的次序不同）

3、与方法的返回值类型不同

## 方法签名

查看方法签名

![image-20240711171803929](../../../Library/Application Support/typora-user-images/image-20240711171803929.png)

由上图可以看出，方法签名只与方法名、方法参数列表有关，因此方法重载只与这二者相关。

## 动态绑定

不同的类可能存在以下现象，系统调用方法的方式完全相同，但却有着不同的功能，因此可以将具有相同调用方式的方法部分进行抽象，化成父类，并结合向上调整机制，使用父类对象格式进行引用，进而触发多态，这就是动态绑定。

## 接口

对于动态绑定提及的父类，如果完全变成一个最高级抽象，就是接口 `interface` ，对接接口的时候使用关键词 `implements` 。

可以将接口定义为代码中的开发规范，在现实生活中很常见，例如电脑上的 USB 接口：

- U 盘插入，可以存放，提取文件
- 键盘插入，可以通过系统输入流输入信息
- 充电线插入，可以使用电脑的电池进行供电

不同的类在调用同一个方法时，有不同的动作，将其高度抽象，形成接口。继承接口的类都要对接口中的方法进行重写，但是这些类的方法名称都是一样的，进而确保了这些类的开发规范是一致的。

开发中，通过将有相同动作的类进行抽象化，做成对应的接口，然后对接口中的方法进行重写，配合向上调整，构成动态绑定机制，形成多态的调用。~~以 `toString` 方法为例，每一个类都可以重写（`overwrite`）`toString` 方法，（错误理解，这里说的是重写，不是多态）~~



## String

`String` 底层是一个 `char` 类型数组，但 `String` 对象本身没有这个数组的空间，而是通过 `value` 变量引用这个 `char` 数组。

`String=String` ：这是一个浅拷贝。

### `StringBuffer` 与 `StringBuilder`

- 由于 `StringBuffer` 的线程安全性是通过内部同步机制实现的，大部分修改状态的方法都使用了 `synchronized` 关键字，这确保了方法的原子性，在同一时间内只有一个线程可以执行这些方法，为了保证这些，就会具备更多的同步机制的开销。因此在单线程环境中，它的性能通常比 `StringBuilder` 差。
- `StringBuilder`由于没有同步机制的开销，因此在单线程环境中性能更好。
- `StringBuffer`和`StringBuilder`都提供了类似的一组方法，如 `append`、`insert`、`delete`、`replace ` 等，用于修改字符串。
- 因为 `StringBuffer` 和 `StringBuilder `的方法中都是直接返回当前的对象，`String `往往都是返回一个新对象，所以这两个对象在进行一些操作（如频繁的 `append` 等）时，会更加高效。

### `String`的`Split`

在Java中，使用`String.split`方法时，如果两个单词之间有两个或更多的空格，那么按空格进行分割时，就会在这两个单词之间产生一个空字符串，进而包含在分割结果数组中。



## 异常

### 受检查异常

`Exception` 和它的子类都是受查异常，这些异常都会在编译时检查，因此要在会出现这些异常的代码所处的方法开头处使用 `throws` 声明异常，否则程序不能正常通过编译。

### 非受检查异常

`RuntimeException` 和它的子类都是非受查异常，不会在编译时检查。

非常详细的异常内容讲解文章：https://zhuanlan.zhihu.com/p/696348474

## Some tips

### `final` 修饰符

`final`修饰的变量值不可以变，但是 Java 中，绝大多数都是引用变量，所以以下情况应要注意。

```java
final int[] arr = new int[]{1, 2, 3, 4, 5};
// 第一种情况
arr = new int[]{1, 2, 3, 4, 5}; // 报错，因为修改了 arr 这个引用变量的值，也就是 array 的地址
// 第二种情况
arr[0] = 1; // 没有问题，因为这是修改的另外一个没有被 final 修饰的空间，故修改不会报错
```

